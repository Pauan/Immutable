/**
   @function fromJSON
   @param {Any} [x]
   @return {Any}
   @summary Converts specially marked JSON to a [::Dict],
            [::Set], [::List], [::Queue], [::Stack], [::Tuple],
            or [::Record]
   @desc
     This function has the following behavior:

     * JavaScript object literals are deeply copied, with
       [::fromJSON] run on all the values.

       This copying takes `O(n)` time.

     * JavaScript arrays are deeply copied, with [::fromJSON]
       run on all the values.

       This copying takes `O(n)` time.

     * `null`, booleans, strings, and [::UUIDTag] are returned
       as-is.

     * Numbers are returned as-is, except `NaN`, `Infinity`,
       and `-Infinity` throw an error.

     * Specially marked JSON objects are converted into a
       [::Dict], [::Set], [::List], [::Queue], [::Stack],
       [::Tuple], or [::Record], with [::fromJSON]
       run on all the keys/values.

       This conversion takes `O(n)` time.

     * Everything else throws an error.

     ----

     You *cannot* use [::Tag] with [::fromJSON], but you
     *can* use [::UUIDTag].

     ----

     This function is useful because it's *lossless*: if you
     use [::toJSON] followed by [::fromJSON], the two objects
     will be equal:

         var x = Record({ foo: 1 });

         // true
         equal(x, fromJSON(toJSON(x)));

     This makes it possible to store immutable objects on disk,
     or send them over the network with JSON, reconstructing
     them on the other side.

     ----

     If you just want to use a library that expects normal
     JavaScript objects, use [::toJS] and [::fromJS] instead.
 */
