/**
   @function defaultSort
   @param {Any} [x] Value to be sorted
   @param {Any} [y] Value to be sorted
   @return {Integer} Whether `x` is lower than, equal to, or greater than `y`
   @summary Returns whether `x` is lower than, equal to, or greater than `y`
   @desc
     This function can be used with [::SortedDict] and [::SortedSet].

     This is the sort used for [::Dict] and [::Set].

     * If `x` is lower than `y`, it returns `-1`
     * If `x` is equal to `y`, it returns `0`
     * If `x` is greater than `y`, it returns `1`

     This function works on everything, including (but not limited to)
     numbers, strings, booleans, mutable objects, [::Dict], [::Set],
     [::List], [::Queue], and [::Stack].

     Equality is the same as [::equal], which means mutable objects
     are only equal if they are exactly the same object, and immutable
     objects (Dict, Set, List, etc.) are equal if they have the same
     keys/values.

     Although this function works on everything, it has two downsides:

     * Equality is well defined, but sorting is not: you should *not* rely
       upon one value being lower than or greater to another value.

       This is because [::defaultSort] first creates hashes of the values,
       and then compares the hashes.

     * It's slower than [::simpleSort], so if you're only using string
       keys, you can gain a bit of speed by using [::simpleSort] instead.

       Of course you should only do that if you have an *actual*
       performance problem, and you've benchmarked to verify that
       the problem is [::defaultSort].
 */
