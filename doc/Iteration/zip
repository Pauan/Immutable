/**
   @function zip
   @param {::Iterable} [x]
   @param {optional Any} [default]
   @return {::Iterable}
   @summary Returns a new [::Iterable] which contains
            alternating values of the iterables of `x`
   @desc
     This function returns an [::Iterable], which is lazy:
     it only generates the values as needed.

     If you want an array, use [::toArray].

     ----

     `x` must be an [::Iterable] which contains multiple
     [::Iterable].

     This function returns an [::Iterable] which contains
     multiple [::Tuple] which contain alternating values
     from each [::Iterable] in `x`:

         // returns [[1, 4], [2, 5], [3, 6]]
         zip([[1, 2, 3], [4, 5, 6]]);

     You can think of it as being similar to a [real-world zipper](http://en.wikipedia.org/wiki/Zipper).

     ----

     It stops when it reaches the end of the shortest iterable:

         // returns [[1, 4, 7]]
         zip([[1, 2, 3], [4, 5, 6], [7]]);

     If you provide a second argument, it will use it to fill in
     the missing spots:

         // returns [[1, 4, 7], [2, 5, 0], [3, 6, 0]]
         zip([[1, 2, 3], [4, 5, 6], [7]], 0);

     ----

     You can undo a zip by simply using [::zip] a second time:

         // returns [[1, 4], [2, 5], [3, 6]]
         var x = zip([[1, 2, 3], [4, 5, 6]]);

         // returns [[1, 2, 3], [4, 5, 6]]
         zip(x);

     ----

     Using [::zip], it's easy to collect all the keys/values
     of a [::Dict] or [::Record]:

         var x = Record({
           foo: 1,
           bar: 2
         });

         // returns [["foo", "bar"], [1, 2]]
         zip(x);
 */
