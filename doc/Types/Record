/**
   @class Record
   @summary An immutable fixed-size dictionary mapping strings to values
   @desc
     A [::Record] is much faster and lighter-weight than a [::Dict],
     but in exchange for that they can only have strings for
     keys, and you cannot add or remove keys from a [::Record].

   @function Record
   @param {optional sequence::Sequence|Object} [obj]
   @desc
     If `obj` is a [sequence::Sequence], the values must
     be arrays of `[key, value]`, which will be added to
     the record.

     If `obj` is a JavaScript literal like `{ foo: 1 }`,
     then the keys/values will be added to the record.

     In either case, the keys must be strings, and they
     will be in the same order as `obj`.

     This takes `O(n)` time, unless `obj` is already
     a [::Record], in which case it takes `O(1)` time.

   @function Record.get
   @param {Any} [key] The key to search for in the record
   @return {Any} The value for `key` in the record
   @summary Returns the value for `key` in the record
   @desc
     This function runs in `O(1)` time.

     If `key` is not in the record, an error is thrown.

   @function Record.set
   @param {Any} [key] The key to set in the record
   @param {Any} [value] The value to use for `key`
   @return {::Record} A new record with `key` set to `value`
   @summary Returns a new record with `key` set to `value`
   @desc
     This function runs in `O(n)` time.

     This does not modify the record, it returns a new record.

     If `key` does not exist, an error is thrown.

   @function Record.modify
   @param {Any} [key] The key to modify in the record
   @param {Function} [fn] The function which will modify the value at `key`
   @return {::Record} A new record with `key` modified by `fn`
   @summary Returns a new record with `key` modified by `fn`
   @desc
     This function runs in `O(n)` time.

     This does not modify the record, it returns a new record.

     This function calls `fn` with the value for `key`, and
     whatever `fn` returns will be used as the new value for
     `key`:

         var record = Record({
           "foo": 1,
           "bar": 2
         });

         // This returns the record { "foo": 11, "bar": 2 }
         record.modify("foo", function (x) { return x + 10 });

         // This returns the record { "foo": 1, "bar": 12 }
         record.modify("bar", function (x) { return x + 10 });

     If `key` is not in the record, it will throw an error.

   @function Record.update
   @param {sequence::Sequence} [other] Sequence of keys/values to update in this record
   @return {::Record} A new record with the keys/values of this record updated with `other`
   @summary Returns a new record with the keys/values of this record updated with `other`
   @desc
     This function runs in `O(log2(n) * m)` worst-case time.

     This does not modify the record, it returns a new record.

     This function returns a [::Record] which contains all the keys/values
     from this record, but updated with the values from `other`.

     If a key from `other` already exists in this record, it is overwritten.

     If a key from `other` does not exist in this record, an error is thrown.

     `other` must be a [sequence::Sequence] where each value
     is an array of `[key, value]`

     You can use this to update a [::Record] with another [::Record]:

         var defaults = Record({
           "foo": 1,
           "bar": 2
         });

         var other = Record({
           "foo": 50
         });

         // { foo: 50, bar: 2 }
         defaults.update(other);
 */
